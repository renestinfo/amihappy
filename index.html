<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Am I Happy Today?</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            background-color: #f0f2f5;
            overflow: hidden;
            cursor: none;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        h1 {
            color: #1a1a1a;
            margin-bottom: 2rem;
            font-size: 3rem;
            text-align: center;
        }

        .answer {
            font-size: 3.5rem;
            font-weight: bold;
            margin: 1rem 0;
            text-align: center;
        }

        .market-info {
            margin-top: 1rem;
            color: #666;
            font-size: 1.2rem;
            text-align: center;
        }

        .really-happy-section {
            margin-top: 3rem;
            text-align: center;
        }

        .really-happy-title {
            font-size: 2rem;
            color: #1a1a1a;
            margin-bottom: 1rem;
        }

        .ticker-input {
            padding: 0.75rem 1rem;
            font-size: 1.2rem;
            border: 2px solid #ccc;
            border-radius: 5px;
            text-transform: uppercase;
            text-align: center;
            width: 150px;
        }

        .really-happy-answer {
            font-size: 2.5rem;
            font-weight: bold;
            margin-top: 1rem;
        }

        .cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 2rem;
            transform: translate(-50%, -50%);
            will-change: transform;
        }

        .other-cursor {
            position: fixed;
            pointer-events: none;
            font-size: 2rem;
            transform: translate(-50%, -50%);
            will-change: transform;
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>Am I Happy Today?</h1>
    <div id="answer" class="answer">Loading...</div>
    <div id="marketInfo" class="market-info">Checking S&P 500...</div>
    
    <div class="really-happy-section">
        <h2 class="really-happy-title">Am I Really Happy?</h2>
        <input type="text" id="tickerInput" class="ticker-input" placeholder="Ticker" maxlength="10">
        <div id="reallyHappyAnswer" class="really-happy-answer"></div>
    </div>
    
    <div id="myCursor" class="cursor">üòê</div>

    <script>
        const cursor = document.getElementById('myCursor');
        const answer = document.getElementById('answer');
        const marketInfo = document.getElementById('marketInfo');
        const tickerInput = document.getElementById('tickerInput');
        const reallyHappyAnswer = document.getElementById('reallyHappyAnswer');
        const otherCursors = new Map();
        const proximityThreshold = 150;
        let isMarketPositive = false;
        let lastCheckTime = 0;
        const checkInterval = 50;
        let userCursorX = 0;
        let userCursorY = 0;

        document.addEventListener('mousemove', (e) => {
            requestAnimationFrame(() => {
                userCursorX = e.clientX;
                userCursorY = e.clientY;
                cursor.style.left = e.clientX + 'px';
                cursor.style.top = e.clientY + 'px';
                
                const now = Date.now();
                if (now - lastCheckTime >= checkInterval) {
                    checkProximity(e.clientX, e.clientY);
                    lastCheckTime = now;
                }
            });
        });

        function checkProximity(userX, userY) {
            let isNearOther = false;

            otherCursors.forEach((otherCursor) => {
                // Check proximity to user cursor
                const dx = userX - otherCursor.x;
                const dy = userY - otherCursor.y;
                const distanceToUser = Math.sqrt(dx * dx + dy * dy);

                // Check proximity to other simulated cursors
                let isNearOtherCursor = false;
                otherCursors.forEach((other) => {
                    if (other.id === otherCursor.id) return;
                    const dx2 = otherCursor.x - other.x;
                    const dy2 = otherCursor.y - other.y;
                    const distanceToOther = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    if (distanceToOther < proximityThreshold) {
                        isNearOtherCursor = true;
                    }
                });

                if (distanceToUser < proximityThreshold || isNearOtherCursor) {
                    isNearOther = true;
                    otherCursor.element.textContent = 'üòä';
                } else {
                    otherCursor.element.textContent = isMarketPositive ? 'ü§î' : 'üòü';
                }
            });

            cursor.textContent = isNearOther ? 'üòä' : (isMarketPositive ? 'ü§î' : 'üòü');
        }

        async function checkMarket() {
            try {
                const response = await fetch('./spy.json', { cache: 'no-store' });
                const data = await response.json();
                
                // Finnhub quote format: { c: current, pc: previous close, ... }
                const changePercent = ((data.c - data.pc) / data.pc) * 100;
                isMarketPositive = changePercent >= 0;
                
                answer.textContent = isMarketPositive ? 'YES! üòä' : 'NO üòü';
                answer.style.color = isMarketPositive ? '#22c55e' : '#ef4444';
                marketInfo.textContent = `SPY is ${isMarketPositive ? 'up' : 'down'} ${Math.abs(changePercent).toFixed(2)}% today`;
                
                cursor.textContent = isMarketPositive ? 'ü§î' : 'üòü';
            } catch (error) {
                answer.textContent = 'Market Closed üò¥';
                marketInfo.textContent = 'Unable to fetch market data';
            }
        }

        async function checkTicker(ticker) {
            if (!ticker || !ticker.trim()) {
                reallyHappyAnswer.textContent = '';
                return;
            }
            
            reallyHappyAnswer.textContent = 'Loading...';
            reallyHappyAnswer.style.color = '#666';
            
            try {
                // Using Yahoo Finance API with CORS proxy
                const symbol = ticker.toUpperCase();
                const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=2d`;
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(yahooUrl)}`;
                
                const response = await fetch(proxyUrl);
                const proxyData = await response.json();
                const data = JSON.parse(proxyData.contents);
                
                if (!data.chart || !data.chart.result || data.chart.result.length === 0) {
                    reallyHappyAnswer.textContent = 'Invalid ticker';
                    reallyHappyAnswer.style.color = '#ef4444';
                    return;
                }
                
                const result = data.chart.result[0];
                const currentPrice = result.meta.regularMarketPrice;
                const previousClose = result.meta.previousClose;
                
                if (!currentPrice || !previousClose) {
                    reallyHappyAnswer.textContent = 'Invalid ticker';
                    reallyHappyAnswer.style.color = '#ef4444';
                    return;
                }
                
                const changePercent = ((currentPrice - previousClose) / previousClose) * 100;
                const isPositive = changePercent >= 0;
                
                reallyHappyAnswer.textContent = isPositive ? 'YES üòä' : 'NO üòü';
                reallyHappyAnswer.style.color = isPositive ? '#22c55e' : '#ef4444';
            } catch (error) {
                reallyHappyAnswer.textContent = 'Error fetching ticker';
                reallyHappyAnswer.style.color = '#ef4444';
            }
        }

        tickerInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkTicker(tickerInput.value.trim());
            }
        });

        function createSimulatedCursor() {
            const id = Date.now() + Math.random();
            const element = document.createElement('div');
            element.className = 'other-cursor';
            element.textContent = isMarketPositive ? 'ü§î' : 'üòü';
            element.style.opacity = '0';
            document.body.appendChild(element);

            const cursor = {
                element,
                id,
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                targetX: Math.random() * window.innerWidth,
                targetY: Math.random() * window.innerHeight,
                speed: 0.5 + Math.random() * 1.5, // pixels per frame
                pauseTime: 0,
                isPaused: false,
                lastUpdate: performance.now()
            };

            otherCursors.set(id, cursor);

            // Fade in
            setTimeout(() => {
                element.style.opacity = '1';
            }, 100);

            // Set random lifetime (5-30 seconds)
            const lifetime = 5000 + Math.random() * 25000;
            setTimeout(() => {
                removeSimulatedCursor(id);
            }, lifetime);

            function animate() {
                if (!otherCursors.has(id)) return;

                const now = performance.now();
                const deltaTime = Math.min(now - cursor.lastUpdate, 50); // cap at 50ms
                cursor.lastUpdate = now;

                // Check if we should pause (like a user thinking/reading)
                if (cursor.isPaused) {
                    cursor.pauseTime -= deltaTime;
                    if (cursor.pauseTime <= 0) {
                        cursor.isPaused = false;
                        // Pick a new target
                        cursor.targetX = Math.random() * window.innerWidth;
                        cursor.targetY = Math.random() * window.innerHeight;
                    }
                } else {
                    // Move toward target
                    const dx = cursor.targetX - cursor.x;
                    const dy = cursor.targetY - cursor.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 10) {
                        // Reached target, pause for a bit
                        cursor.isPaused = true;
                        cursor.pauseTime = 500 + Math.random() * 2000; // 0.5-2.5 seconds
                    } else {
                        // Move toward target
                        const moveDistance = cursor.speed * (deltaTime / 16); // normalize to 60fps
                        const moveX = (dx / distance) * moveDistance;
                        const moveY = (dy / distance) * moveDistance;
                        
                        cursor.x += moveX;
                        cursor.y += moveY;
                    }

                    // Occasionally change direction (like exploring)
                    if (Math.random() < 0.01) {
                        cursor.targetX = Math.random() * window.innerWidth;
                        cursor.targetY = Math.random() * window.innerHeight;
                    }
                }

                // Keep within bounds
                cursor.x = Math.max(0, Math.min(window.innerWidth, cursor.x));
                cursor.y = Math.max(0, Math.min(window.innerHeight, cursor.y));

                element.style.left = cursor.x + 'px';
                element.style.top = cursor.y + 'px';

                // Check proximity to user cursor and other cursors
                const dx = userCursorX - cursor.x;
                const dy = userCursorY - cursor.y;
                const distanceToUser = Math.sqrt(dx * dx + dy * dy);
                
                let isNearOther = false;
                otherCursors.forEach((other) => {
                    if (other.id === cursor.id) return;
                    const dx2 = cursor.x - other.x;
                    const dy2 = cursor.y - other.y;
                    const distanceToOther = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    if (distanceToOther < proximityThreshold) {
                        isNearOther = true;
                    }
                });
                
                if (distanceToUser < proximityThreshold || isNearOther) {
                    cursor.element.textContent = 'üòä';
                } else {
                    cursor.element.textContent = isMarketPositive ? 'ü§î' : 'üòü';
                }

                requestAnimationFrame(animate);
            }

            requestAnimationFrame(animate);
        }

        function removeSimulatedCursor(id) {
            const cursor = otherCursors.get(id);
            if (cursor) {
                // Fade out
                cursor.element.style.opacity = '0';
                setTimeout(() => {
                    cursor.element.remove();
                    otherCursors.delete(id);
                }, 300);
            }
        }

        // Manage cursor population (2-5 cursors at a time)
        function manageCursors() {
            const targetCount = 2 + Math.floor(Math.random() * 4); // 2-5 cursors
            
            if (otherCursors.size < targetCount) {
                // Add a new cursor
                setTimeout(() => createSimulatedCursor(), Math.random() * 2000);
            }
        }

        checkMarket();
        setInterval(checkMarket, 60000);

        // Create initial cursors
        for (let i = 0; i < 2; i++) {
            setTimeout(() => createSimulatedCursor(), i * 2000);
        }

        // Periodically manage cursor population
        setInterval(manageCursors, 5000);
    </script>
</body>
</html>